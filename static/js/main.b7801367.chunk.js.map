{"version":3,"sources":["index.js"],"names":["Cell","this","props","value","isRevealed","isMine","neighbouringMines","isFlagged","cellClassName","className","onClick","onContextMenu","cellValue","React","Component","Board","state","boardData","initialiseBoard","height","width","mines","gameWon","i","push","j","x","y","setMines","findNeighbouringMines","randomX","randomY","minesSet","Math","floor","random","neighbouringCells","length","cells","updatedData","setState","map","cell","revealNeighbours","hiddenCells","revealBoard","winningState","countHiddenCells","e","preventDefault","row","handleClick","handleRightClick","renderBoard","Game","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.b7801367.chunk.js","sourcesContent":["import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\n\nclass Cell extends React.Component {\n  cellValue() {\n    if (!this.props.value.isRevealed) {\n      return this.props.value.isFlagged ? \"üèÅ\" : null;\n    }\n\n    if (this.props.value.isMine) {\n      return \"üí•\";\n    }\n\n    if (this.props.value.neighbouringMines === 0) {\n      return null;\n    }\n\n    return this.props.value.neighbouringMines;\n  }\n\n  render() {\n    let cellClassName = \"cell\" + (this.props.value.isRevealed ? \"\" : \"-hidden\");\n\n    return (\n      <button\n        className={cellClassName}\n        onClick={this.props.onClick}\n        onContextMenu={this.props.onContextMenu}\n      >\n        {this.cellValue()}\n      </button>\n    );\n  }\n}\n\nclass Board extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      boardData: this.initialiseBoard(\n        this.props.height,\n        this.props.width,\n        this.props.mines\n      ),\n      gameWon: false,\n    };\n  }\n\n  initialiseBoard(height, width, mines) {\n    let boardData = [];\n\n    //  initialise the state for each cell\n    //  x, y are the coordinates of the cell in the board\n    for (let i = 0; i < height; i++) {\n      boardData.push([]);\n      for (let j = 0; j < width; j++) {\n        boardData[i][j] = {\n          x: i,\n          y: j,\n          isMine: false,\n          neighbouringMines: 0,\n          isFlagged: false,\n          isRevealed: false,\n        };\n      }\n    }\n\n    // set the mines in the board\n    boardData = this.setMines(boardData, mines);\n\n    // set the value for non-mine cells, how many neighbouring mines?\n    boardData = this.findNeighbouringMines(boardData);\n\n    // return the initalised boardData to Board's state\n    return boardData;\n  }\n\n  setMines(boardData, mines) {\n    let randomX = 0;\n    let randomY = 0;\n    let minesSet = 0;\n\n    while (minesSet < mines) {\n      randomX = Math.floor(Math.random() * this.props.width);\n      randomY = Math.floor(Math.random() * this.props.height);\n\n      // if the cell does not already contain a mine, place\n      // a mine, otherwise skip and continue to loop\n      if (!boardData[randomY][randomX].isMine) {\n        boardData[randomY][randomX].isMine = true;\n        minesSet++;\n      }\n    }\n    return boardData;\n  }\n\n  findNeighbouringMines(boardData) {\n    for (let i = 0; i < this.props.height; i++) {\n      for (let j = 0; j < this.props.width; j++) {\n        // if the cell is not a mine, identify how many neighbours\n        // are mines\n        if (!boardData[i][j].isMine) {\n          let neighbouringMines = 0;\n          const neighbouringCells = this.neighbouringCells(\n            boardData[i][j].x,\n            boardData[i][j].y,\n            boardData\n          );\n\n          for (let x = 0; x < neighbouringCells.length; x++) {\n            if (neighbouringCells[x].isMine) {\n              neighbouringMines++;\n            }\n          }\n\n          boardData[i][j].neighbouringMines = neighbouringMines;\n        }\n      }\n    }\n\n    return boardData;\n  }\n\n  neighbouringCells(x, y, boardData) {\n    let cells = [];\n\n    const height = this.props.height;\n    const width = this.props.width;\n\n    // the following statements ensure that we do\n    // not look outside the array\n\n    // to the left\n    if (x > 0) {\n      cells.push(boardData[x - 1][y]);\n    }\n\n    // to the top-left\n    if (x > 0 && y > 0) {\n      cells.push(boardData[x - 1][y - 1]);\n    }\n\n    // to the top\n    if (y > 0) {\n      cells.push(boardData[x][y - 1]);\n    }\n\n    // to the top-right\n    if (x < width - 1 && y > 0) {\n      cells.push(boardData[x + 1][y - 1]);\n    }\n\n    // to the right\n    if (x < width - 1) {\n      cells.push(boardData[x + 1][y]);\n    }\n\n    // to the bottom-right\n    if (x < width - 1 && y < height - 1) {\n      cells.push(boardData[x + 1][y + 1]);\n    }\n\n    // to the bottom\n    if (y < height - 1) {\n      cells.push(boardData[x][y + 1]);\n    }\n\n    // to the bottom-left\n    if (x > 0 && y < height - 1) {\n      cells.push(boardData[x - 1][y + 1]);\n    }\n\n    return cells;\n  }\n\n  revealBoard() {\n    let updatedData = this.state.boardData;\n\n    for (let i = 0; i < this.props.height; i++) {\n      for (let j = 0; j < this.props.width; j++) {\n        if (!updatedData[i][j].isRevealed) {\n          updatedData[i][j].isRevealed = true;\n        }\n      }\n    }\n\n    this.setState({\n      boardData: updatedData,\n    });\n  }\n\n  revealNeighbours(x, y, boardData) {\n    // recursive function to reveal surrounding cells until finding a cell with\n    // at least one adjacent mine\n\n    let neighbours = this.neighbouringCells(x, y, boardData);\n\n    neighbours.map((cell) => {\n      if (!cell.isRevealed && !cell.isMine) {\n        boardData[cell.x][cell.y].isRevealed = true;\n        if (cell.neighbouringMines === 0) {\n          this.revealNeighbours(cell.x, cell.y, boardData);\n        }\n      }\n    });\n\n    return boardData;\n  }\n\n  countHiddenCells(boardData) {\n    let hiddenCells = 0;\n    for (let i = 0; i < this.props.height; i++) {\n      for (let j = 0; j < this.props.width; j++) {\n        if (!boardData[i][j].isRevealed) {\n          hiddenCells++;\n        }\n      }\n    }\n    return hiddenCells;\n  }\n\n  handleClick(x, y) {\n    // if the square is already revealed, a click does nothing\n    if (this.state.boardData[x][y].isRevealed) {\n      return null;\n    }\n\n    // if the player clicks on a mine, the game is over and the board is revealed\n    if (this.state.boardData[x][y].isMine) {\n      this.revealBoard();\n    }\n\n    let updatedData = this.state.boardData;\n\n    // if there is at least one neighbouring mine, reveal the cell\n    // (this will show a number in the cell)\n    if (this.state.boardData[x][y].neighbouringMines !== 0) {\n      updatedData[x][y].isRevealed = true;\n    }\n\n    // if the cell has no neighbouring cells, call the recursive\n    // function to reveal cells until mines are hit\n    if (this.state.boardData[x][y].neighbouringMines === 0) {\n      updatedData = this.revealNeighbours(x, y, updatedData);\n    }\n\n    let winningState = false;\n\n    // if the only hidden cells are mines, the game is won\n    if (this.countHiddenCells(updatedData) === this.props.mines) {\n      this.revealBoard();\n      winningState = true;\n    }\n\n    this.setState({\n      boardData: updatedData,\n      gameWon: winningState,\n    });\n  }\n\n  handleRightClick(e, x, y) {\n    e.preventDefault();\n\n    let updatedData = this.state.boardData;\n\n    if (updatedData[x][y].isRevealed) {\n      return;\n    }\n\n    if (updatedData[x][y].isFlagged) {\n      updatedData[x][y].isFlagged = false;\n    } else {\n      updatedData[x][y].isFlagged = true;\n    }\n\n    this.setState({\n      boardData: updatedData,\n    });\n  }\n\n  renderBoard(boardData) {\n    return boardData.map((row) => {\n      return row.map((cell) => {\n        return (\n          <div>\n            <Cell\n              value={cell}\n              onClick={() => this.handleClick(cell.x, cell.y)}\n              onContextMenu={(e) => this.handleRightClick(e, cell.x, cell.y)}\n            />\n            {row[row.length - 1] === cell ? <div className=\"board-row\" /> : \"\"}\n          </div>\n        );\n      });\n    });\n  }\n\n  render() {\n    return (\n      <div className=\"board\">\n        <div className=\"status-info\">\n          <p>{this.state.gameWon ? \"You won!\" : \"Keep searching....\"}</p>\n        </div>\n        <div>{this.renderBoard(this.state.boardData)}</div>\n      </div>\n    );\n  }\n}\n\nclass Game extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      height: 11,\n      width: 11,\n      mines: 15,\n    };\n  }\n\n  render() {\n    const { height, width, mines } = this.state;\n    return (\n      <div className=\"game\">\n        <h1>Minesweeper Game!</h1>\n        <p>Left-click to reveal cells - don't hit the mines!</p>\n        <p>\n          Numbers in revealed cells show how many mines are next to that cell\n        </p>\n        <p>Right click to add/remove flags</p>\n        <p>Number of mines in the board: {mines}</p>\n        <div className=\"game-board\">\n          <Board height={height} width={width} mines={mines} />\n        </div>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(<Game />, document.getElementById(\"root\"));\n"],"sourceRoot":""}